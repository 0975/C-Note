[{"id":"1761930370791","title":"引用","content":"###什么是引用？\n引用是目标变量的别名（不是独立变量，无自己的内存空间，操作引用 = 操作原变量）；\n\n\n\n例如：\nint a = 10；\n\n\n//b就是a的别名，是a的一个分身，对b操作就是对a操作。&符号就代表着b和a绑定\n\n\nint &b = a;\n\n⚠️ 引用不是数据类型，它只是所绑定对象的一个别名，所以引用必须初始化。\n⚠️ 引用一旦绑定某个对象，终身不能改绑其他对象（区别于指针，指针可以指向不同对象）。\n\n⚠️ 普通引用的类型必须与所绑定对象的数据类型一致，因为引用仅仅是个别名，但是有一个例外，就是常量引用，常量引用可以绑定非常量的数据类型并且可以和绑定的数据类型不同。例如:\n\n\ndouble c = 20；\n\n\nconst int &d = c; \n\n这是因为当常量引用绑定 “类型不匹配的对象” 或 “临时值” 时，编译器会自动做 3 件事：\n\n\n\n1.创建一个与引用类型一致的临时变量（如const int &d = c;时，创建临时 int 变量 temp = (int) c）；\n\n\n2.将原对象的值（或字面量）赋值给这个临时变量；\n\n\n3.让常量引用绑定到这个临时变量上。\n注意：此时引用操作的是 “临时变量”，而非原对象！原对象的值不会被修改（因为临时变量是独立的，且引用是 const 的，也不能修改临时变量）。","createTime":"2025/11/01 01:06","updateTime":"2025/11/01 01:19"},{"id":"1761929108604","title":"指针","content":"###什么是指针？\n\n\n指针是一种数据类型，它也是一个对象拥有自己的储存空间，自己的地址值。\n\n它的写法：\n\nint a = 10;\n\n\nint *b = &a;\n\nb就是一个指针，变量名*代表这是一个指针，并且这个指针指向a；\n\n&a就是a的地址值，“&”符号是取地址符号。\n\n\n如果要输出指针所指对象的具体的值需要用到解引符号“*”,\"*\"和变量单独使用时就是解引符，具体的作用根据上下文来判断\n\n使用方法：cout<<*b<<endl;\n\n空指针：\n\n空指针就是没有指向任何对象的指针。\n\n\n空指针的写法：\n\n1.int *c = 0;\n\n2.int *d = nullptr;\n\n3.int *e = NULL;//注意NULL头文件必须包含cstd\n\n\n指针的内容：\n\n\n1.空对象\n\n2.所指对象的下一个内容\n\n3.所指对象的地址值\n\n4.？忘记了\n\n指针的指针：就是一个指针指向了另一个指针，那这个指针就是指针的指针。\n\n看指针的到底指向了几个对象可以这样看，先看最左侧的*，说明它是一个指针，然后从数后面的*号，指针的指向的数量是n-1；\nint *p = 10;\nint **d = p;\n⚠️ 三级指针只能指向二级指针，二级指针不能指向三级指针\n\n指向常量的指针，最左侧是const，这是一个底层const，该指针一旦确认就不能在修改其所指对象的值，但是可以对其所指对象的类型不做特别要求\n\nconst int *a = &a;\n\n常量指针，指针本身是常量，所以一旦确定就不能改变，故而常量指针必须初始化","createTime":"2025/11/01 00:45","updateTime":"2025/11/01 19:38"}]