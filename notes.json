[{"id":"1762005520212","title":"auto","content":"auto是为了应对判断表达式结果类型而诞生的一种类型，它可以在编译是通过初始值来推断变量的类型，因为需要初始值，所以auto类型必须初始化\n\nauto item = vall + val2；\n\n上面等式，auto通过后面两个值相加后的结果推算类型\n\n⚠️ auto一般会忽略顶层const\n\n⚠️ 编译器推断出来的auto类型有时候和等式后面的初始值不一样，这是因为编译器会适当改变结果类型使其更符合初始化规则\n\n例子1，顶层const被丢弃\n\n\nconst int a = 10; // a 的原始类型：const int（顶层 const）\n\n\nauto b = a;       // auto 推断 b 的类型：int（丢弃了顶层 const）\n\n\n\n// 验证：b 不是 const，可修改\n\n\nb = 20; // 合法，不会报错（如果 b 是 const int，这里会编译报错）\n\n\n\n// 对比：如果想让 b 保留 const，需要显式加 const\nconst auto c = a; // c 的类型：const int（显式保留顶层 const）\n\n\nc = 30; // 编译报错：c 是 const，不可修改\n\n例子2:数组退化为指针\n\n数组名作为初始值时，auto 不会推断为 “数组类型”，而是推断为 “指向数组元素的指针类型”（这是 C++ 数组的默认隐式转换规则）。\n\nint arr[5] = {1,2,3,4,5}; // arr 的原始类型：int[5]（5个int的数组）\n\nauto p = arr;              // auto 推断 p 的类型：\n\nint*（指针，不是数组）\n\n// 验证：p 是指针，可以指向数组元素\n\n\np = &arr[2]; // 合法，p 指向 arr[2]（值为3）\n\n\n\n// 对比：如果想让 auto 推断为数组类型，需要加 &（引用）\n\n\nauto& arr_ref = arr; // arr_ref 的类型：int(&)[5]（数组的引用）\n\n\narr_ref[0] = 100; // 合法，修改数组第一个元素\n\n\n\n例子3:引用的“值类型”被提取","createTime":"2025/11/01 21:58","updateTime":"2025/11/01 22:52"},{"id":"1762005092901","title":"类型别名","content":"类型别名是为了让类型能更让开发者理解其意思而取的名字\n\n⚠️：类型别名不仅仅简单的文字替换\n\n使用方法：\n\ntypedef 类型 类型别名\n\ntypedef char* ctr；\n\nconst ctr；//这时候ctr是一个常量指针而不是指向常量的指针\n\n类型别名的新方法\nusing 类型 = 类型别名；\n\n总结（一句话巩固）\n\n\n类型别名核心是 “让类型更易理解 / 简化复杂类型”，不是单纯文字替换；\n\n\n两种写法都正确：typedef 原类型 别名（传统）、using 别名 = 原类型（推荐）；\n\n\n和 const 结合时，类型别名是 “整体类型加 const”，不是拆分替换（这是和宏的关键区别）。","createTime":"2025/11/01 21:51","updateTime":"2025/11/01 21:53"},{"id":"1762004473856","title":"如何在多个文件里使用同一个常量","content":"在头文件中加上extern const int 常量名；","createTime":"2025/11/01 21:41","updateTime":"2025/11/01 21:41"},{"id":"1761930370791","title":"引用","content":"###什么是引用？\n引用是目标变量的别名（不是独立变量，无自己的内存空间，操作引用 = 操作原变量）；\n\n\n\n例如：\nint a = 10；\n\n\n//b就是a的别名，是a的一个分身，对b操作就是对a操作。&符号就代表着b和a绑定\n\n\nint &b = a;\n\n⚠️ 引用不是数据类型，它只是所绑定对象的一个别名，所以引用必须初始化。\n⚠️ 引用一旦绑定某个对象，终身不能改绑其他对象（区别于指针，指针可以指向不同对象）。\n\n⚠️ 普通引用的类型必须与所绑定对象的数据类型一致，因为引用仅仅是个别名，但是有一个例外，就是常量引用，常量引用可以绑定非常量的数据类型并且可以和绑定的数据类型不同。例如:\n\n\ndouble c = 20；\n\n\nconst int &d = c; \n\n这是因为当常量引用绑定 “类型不匹配的对象” 或 “临时值” 时，编译器会自动做 3 件事：\n\n\n\n1.创建一个与引用类型一致的临时变量（如const int &d = c;时，创建临时 int 变量 temp = (int) c）；\n\n\n2.将原对象的值（或字面量）赋值给这个临时变量；\n\n\n3.让常量引用绑定到这个临时变量上。\n注意：此时引用操作的是 “临时变量”，而非原对象！原对象的值不会被修改（因为临时变量是独立的，且引用是 const 的，也不能修改临时变量）。","createTime":"2025/11/01 01:06","updateTime":"2025/11/01 01:19"},{"id":"1761929108604","title":"指针","content":"###什么是指针？\n\n\n指针是一种数据类型，它也是一个对象拥有自己的储存空间，自己的地址值。\n\n它的写法：\n\nint a = 10;\n\n\nint *b = &a;\n\nb就是一个指针，变量名*代表这是一个指针，并且这个指针指向a；\n\n&a就是a的地址值，“&”符号是取地址符号。\n\n\n如果要输出指针所指对象的具体的值需要用到解引符号“*”,\"*\"和变量单独使用时就是解引符，具体的作用根据上下文来判断\n\n使用方法：cout<<*b<<endl;\n\n空指针：\n\n空指针就是没有指向任何对象的指针。\n\n\n空指针的写法：\n\n1.int *c = 0;\n\n2.int *d = nullptr;\n\n3.int *e = NULL;//注意NULL头文件必须包含cstd\n\n\n指针的内容：\n\n\n1.空对象\n\n2.所指对象的下一个内容\n\n3.所指对象的地址值\n\n4.？忘记了\n\n指针的指针：就是一个指针指向了另一个指针，那这个指针就是指针的指针。\n\n看指针的到底指向了几个对象可以这样看，先看最左侧的*，说明它是一个指针，然后从数后面的*号，指针的指向的数量是n-1；\nint *p = 10;\nint **d = p;\n⚠️ 三级指针只能指向二级指针，二级指针不能指向三级指针\n\n指向常量的指针，最左侧是const，这是一个底层const，该指针一旦确认就不能在修改其所指对象的值，但是可以对其所指对象的类型不做特别要求\n\nconst int *a = &a;\n\n常量指针，指针本身是常量，所以一旦确定就不能改变，故而常量指针必须初始化。常量指针的const是顶层const。\n\nint *const p =&c；\n\n有时候需要一个值编译器就要确定，这时候就要用constexpr，用了constexpr后面就不需要用const了，constexpr相当于高级const，在编译器如果要让值确定就用这个，有constexpr的后面必定是常量，但是const不一定是constexpr。\n\nconstexpr int a = 20;//编译器就知道a = 20；\n\nconstexpr int b = 20 + a；\n\n两者本质区别，const代表不可修改，constexpr代表编译器确定，constexpr只能用于简单的基本类型，不能用于复杂类型","createTime":"2025/11/01 00:45","updateTime":"2025/11/01 21:43"}]